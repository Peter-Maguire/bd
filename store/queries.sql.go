// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const friends = `-- name: Friends :many
SELECT  steam_id, steam_id_friend, friend_since, created_on
FROM player_friends
WHERE steam_id = ?1
`

func (q *Queries) Friends(ctx context.Context, steamID int64) ([]PlayerFriend, error) {
	rows, err := q.query(ctx, q.friendsStmt, friends, steamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerFriend
	for rows.Next() {
		var i PlayerFriend
		if err := rows.Scan(
			&i.SteamID,
			&i.SteamIDFriend,
			&i.FriendSince,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const friendsDelete = `-- name: FriendsDelete :exec
DELETE FROM player_friends WHERE steam_id = ?1
`

func (q *Queries) FriendsDelete(ctx context.Context, steamID int64) error {
	_, err := q.exec(ctx, q.friendsDeleteStmt, friendsDelete, steamID)
	return err
}

const friendsInsert = `-- name: FriendsInsert :exec
INSERT INTO player_friends (steam_id, steam_id_friend, friend_since, created_on)
VALUES (?, ?, ?, ?)
`

type FriendsInsertParams struct {
	SteamID       int64     `json:"steam_id"`
	SteamIDFriend int64     `json:"steam_id_friend"`
	FriendSince   time.Time `json:"friend_since"`
	CreatedOn     time.Time `json:"created_on"`
}

func (q *Queries) FriendsInsert(ctx context.Context, arg FriendsInsertParams) error {
	_, err := q.exec(ctx, q.friendsInsertStmt, friendsInsert,
		arg.SteamID,
		arg.SteamIDFriend,
		arg.FriendSince,
		arg.CreatedOn,
	)
	return err
}

const lists = `-- name: Lists :many
SELECT list_id, list_type, url, enabled, updated_on, created_on
FROM lists
`

func (q *Queries) Lists(ctx context.Context) ([]List, error) {
	rows, err := q.query(ctx, q.listsStmt, lists)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []List
	for rows.Next() {
		var i List
		if err := rows.Scan(
			&i.ListID,
			&i.ListType,
			&i.Url,
			&i.Enabled,
			&i.UpdatedOn,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listsDelete = `-- name: ListsDelete :exec
DELETE FROM lists WHERE list_id = ?1
`

func (q *Queries) ListsDelete(ctx context.Context, listID interface{}) error {
	_, err := q.exec(ctx, q.listsDeleteStmt, listsDelete, listID)
	return err
}

const listsInsert = `-- name: ListsInsert :one
INSERT INTO lists (list_type, url, enabled, updated_on, created_on)
VALUES (?, ?, ?, ?, ?)
RETURNING list_id, list_type, url, enabled, updated_on, created_on
`

type ListsInsertParams struct {
	ListType  int64     `json:"list_type"`
	Url       string    `json:"url"`
	Enabled   bool      `json:"enabled"`
	UpdatedOn time.Time `json:"updated_on"`
	CreatedOn time.Time `json:"created_on"`
}

func (q *Queries) ListsInsert(ctx context.Context, arg ListsInsertParams) (List, error) {
	row := q.queryRow(ctx, q.listsInsertStmt, listsInsert,
		arg.ListType,
		arg.Url,
		arg.Enabled,
		arg.UpdatedOn,
		arg.CreatedOn,
	)
	var i List
	err := row.Scan(
		&i.ListID,
		&i.ListType,
		&i.Url,
		&i.Enabled,
		&i.UpdatedOn,
		&i.CreatedOn,
	)
	return i, err
}

const listsUpdate = `-- name: ListsUpdate :exec
UPDATE lists
SET
    list_type = ?1,
    url = ?2,
    enabled = ?3,
    updated_on = ?4
WHERE list_id = ?5
`

type ListsUpdateParams struct {
	ListType  int64       `json:"list_type"`
	Url       string      `json:"url"`
	Enabled   bool        `json:"enabled"`
	UpdatedOn time.Time   `json:"updated_on"`
	ListID    interface{} `json:"list_id"`
}

func (q *Queries) ListsUpdate(ctx context.Context, arg ListsUpdateParams) error {
	_, err := q.exec(ctx, q.listsUpdateStmt, listsUpdate,
		arg.ListType,
		arg.Url,
		arg.Enabled,
		arg.UpdatedOn,
		arg.ListID,
	)
	return err
}

const messageSave = `-- name: MessageSave :exec
INSERT INTO player_messages (steam_id, message, team, dead, created_on)
VALUES (?, ?, ?, ?, ?)
`

type MessageSaveParams struct {
	SteamID   int64     `json:"steam_id"`
	Message   string    `json:"message"`
	Team      bool      `json:"team"`
	Dead      bool      `json:"dead"`
	CreatedOn time.Time `json:"created_on"`
}

func (q *Queries) MessageSave(ctx context.Context, arg MessageSaveParams) error {
	_, err := q.exec(ctx, q.messageSaveStmt, messageSave,
		arg.SteamID,
		arg.Message,
		arg.Team,
		arg.Dead,
		arg.CreatedOn,
	)
	return err
}

const messages = `-- name: Messages :many
SELECT message_id, steam_id, message, team, dead, created_on
FROM player_messages
WHERE steam_id = ?1
`

func (q *Queries) Messages(ctx context.Context, steamID int64) ([]PlayerMessage, error) {
	rows, err := q.query(ctx, q.messagesStmt, messages, steamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerMessage
	for rows.Next() {
		var i PlayerMessage
		if err := rows.Scan(
			&i.MessageID,
			&i.SteamID,
			&i.Message,
			&i.Team,
			&i.Dead,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const player = `-- name: Player :one
SELECT p.steam_id,
       p.visibility,
       p.real_name,
       p.account_created_on,
       p.avatar_hash,
       p.community_banned,
       p.game_bans,
       p.vac_bans,
       p.last_vac_ban_on,
       p.kills_on,
       p.deaths_by,
       p.rage_quits,
       p.notes,
       p.whitelist,
       p.created_on,
       p.updated_on,
       p.profile_updated_on,
       p.personaname
FROM player p
WHERE p.steam_id = ?1
`

type PlayerRow struct {
	SteamID          int64        `json:"steam_id"`
	Visibility       int64        `json:"visibility"`
	RealName         string       `json:"real_name"`
	AccountCreatedOn time.Time    `json:"account_created_on"`
	AvatarHash       string       `json:"avatar_hash"`
	CommunityBanned  bool         `json:"community_banned"`
	GameBans         int64        `json:"game_bans"`
	VacBans          int64        `json:"vac_bans"`
	LastVacBanOn     sql.NullTime `json:"last_vac_ban_on"`
	KillsOn          int64        `json:"kills_on"`
	DeathsBy         int64        `json:"deaths_by"`
	RageQuits        int64        `json:"rage_quits"`
	Notes            string       `json:"notes"`
	Whitelist        bool         `json:"whitelist"`
	CreatedOn        time.Time    `json:"created_on"`
	UpdatedOn        time.Time    `json:"updated_on"`
	ProfileUpdatedOn time.Time    `json:"profile_updated_on"`
	Personaname      string       `json:"personaname"`
}

func (q *Queries) Player(ctx context.Context, steamID int64) (PlayerRow, error) {
	row := q.queryRow(ctx, q.playerStmt, player, steamID)
	var i PlayerRow
	err := row.Scan(
		&i.SteamID,
		&i.Visibility,
		&i.RealName,
		&i.AccountCreatedOn,
		&i.AvatarHash,
		&i.CommunityBanned,
		&i.GameBans,
		&i.VacBans,
		&i.LastVacBanOn,
		&i.KillsOn,
		&i.DeathsBy,
		&i.RageQuits,
		&i.Notes,
		&i.Whitelist,
		&i.CreatedOn,
		&i.UpdatedOn,
		&i.ProfileUpdatedOn,
		&i.Personaname,
	)
	return i, err
}

const playerInsert = `-- name: PlayerInsert :one
INSERT INTO player (steam_id, personaname, visibility, real_name, account_created_on,
                    avatar_hash, community_banned, game_bans, vac_bans, last_vac_ban_on,
                    kills_on, deaths_by, rage_quits, notes, whitelist, profile_updated_on,
                    created_on, updated_on)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING steam_id, personaname, visibility, real_name, account_created_on, avatar_hash, community_banned, game_bans, vac_bans, last_vac_ban_on, kills_on, deaths_by, rage_quits, notes, whitelist, profile_updated_on, created_on, updated_on
`

type PlayerInsertParams struct {
	SteamID          int64        `json:"steam_id"`
	Personaname      string       `json:"personaname"`
	Visibility       int64        `json:"visibility"`
	RealName         string       `json:"real_name"`
	AccountCreatedOn time.Time    `json:"account_created_on"`
	AvatarHash       string       `json:"avatar_hash"`
	CommunityBanned  bool         `json:"community_banned"`
	GameBans         int64        `json:"game_bans"`
	VacBans          int64        `json:"vac_bans"`
	LastVacBanOn     sql.NullTime `json:"last_vac_ban_on"`
	KillsOn          int64        `json:"kills_on"`
	DeathsBy         int64        `json:"deaths_by"`
	RageQuits        int64        `json:"rage_quits"`
	Notes            string       `json:"notes"`
	Whitelist        bool         `json:"whitelist"`
	ProfileUpdatedOn time.Time    `json:"profile_updated_on"`
	CreatedOn        time.Time    `json:"created_on"`
	UpdatedOn        time.Time    `json:"updated_on"`
}

func (q *Queries) PlayerInsert(ctx context.Context, arg PlayerInsertParams) (Player, error) {
	row := q.queryRow(ctx, q.playerInsertStmt, playerInsert,
		arg.SteamID,
		arg.Personaname,
		arg.Visibility,
		arg.RealName,
		arg.AccountCreatedOn,
		arg.AvatarHash,
		arg.CommunityBanned,
		arg.GameBans,
		arg.VacBans,
		arg.LastVacBanOn,
		arg.KillsOn,
		arg.DeathsBy,
		arg.RageQuits,
		arg.Notes,
		arg.Whitelist,
		arg.ProfileUpdatedOn,
		arg.CreatedOn,
		arg.UpdatedOn,
	)
	var i Player
	err := row.Scan(
		&i.SteamID,
		&i.Personaname,
		&i.Visibility,
		&i.RealName,
		&i.AccountCreatedOn,
		&i.AvatarHash,
		&i.CommunityBanned,
		&i.GameBans,
		&i.VacBans,
		&i.LastVacBanOn,
		&i.KillsOn,
		&i.DeathsBy,
		&i.RageQuits,
		&i.Notes,
		&i.Whitelist,
		&i.ProfileUpdatedOn,
		&i.CreatedOn,
		&i.UpdatedOn,
	)
	return i, err
}

const playerSearch = `-- name: PlayerSearch :many
SELECT p.steam_id,
       p.visibility,
       p.real_name,
       p.account_created_on,
       p.avatar_hash,
       p.community_banned,
       p.game_bans,
       p.vac_bans,
       p.last_vac_ban_on,
       p.kills_on,
       p.deaths_by,
       p.rage_quits,
       p.notes,
       p.whitelist,
       p.profile_updated_on,
       p.created_on,
       p.updated_on,
       p.personaname
FROM player p
WHERE (?1 = 0 OR p.steam_id = ?1)
  AND (?2 IS '' OR p.personaname LIKE ?2)
ORDER BY p.updated_on DESC
LIMIT 1000
`

type PlayerSearchParams struct {
	SteamID interface{} `json:"steam_id"`
	Name    interface{} `json:"name"`
}

type PlayerSearchRow struct {
	SteamID          int64        `json:"steam_id"`
	Visibility       int64        `json:"visibility"`
	RealName         string       `json:"real_name"`
	AccountCreatedOn time.Time    `json:"account_created_on"`
	AvatarHash       string       `json:"avatar_hash"`
	CommunityBanned  bool         `json:"community_banned"`
	GameBans         int64        `json:"game_bans"`
	VacBans          int64        `json:"vac_bans"`
	LastVacBanOn     sql.NullTime `json:"last_vac_ban_on"`
	KillsOn          int64        `json:"kills_on"`
	DeathsBy         int64        `json:"deaths_by"`
	RageQuits        int64        `json:"rage_quits"`
	Notes            string       `json:"notes"`
	Whitelist        bool         `json:"whitelist"`
	ProfileUpdatedOn time.Time    `json:"profile_updated_on"`
	CreatedOn        time.Time    `json:"created_on"`
	UpdatedOn        time.Time    `json:"updated_on"`
	Personaname      string       `json:"personaname"`
}

func (q *Queries) PlayerSearch(ctx context.Context, arg PlayerSearchParams) ([]PlayerSearchRow, error) {
	rows, err := q.query(ctx, q.playerSearchStmt, playerSearch, arg.SteamID, arg.Name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerSearchRow
	for rows.Next() {
		var i PlayerSearchRow
		if err := rows.Scan(
			&i.SteamID,
			&i.Visibility,
			&i.RealName,
			&i.AccountCreatedOn,
			&i.AvatarHash,
			&i.CommunityBanned,
			&i.GameBans,
			&i.VacBans,
			&i.LastVacBanOn,
			&i.KillsOn,
			&i.DeathsBy,
			&i.RageQuits,
			&i.Notes,
			&i.Whitelist,
			&i.ProfileUpdatedOn,
			&i.CreatedOn,
			&i.UpdatedOn,
			&i.Personaname,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const playerUpdate = `-- name: PlayerUpdate :exec
UPDATE player
SET visibility         = ?1,
    real_name          = ?2,
    account_created_on = ?3,
    avatar_hash        = ?4,
    community_banned   = ?5,
    game_bans          = ?6,
    vac_bans           = ?7,
    last_vac_ban_on    = ?8,
    kills_on           = ?9,
    deaths_by          = ?10,
    rage_quits         = ?11,
    notes              = ?12,
    whitelist          = ?13,
    updated_on         = ?14,
    profile_updated_on = ?15,
    personaname        = ?16
WHERE steam_id = ?17
`

type PlayerUpdateParams struct {
	Visibility       int64        `json:"visibility"`
	RealName         string       `json:"real_name"`
	AccountCreatedOn time.Time    `json:"account_created_on"`
	AvatarHash       string       `json:"avatar_hash"`
	CommunityBanned  bool         `json:"community_banned"`
	GameBans         int64        `json:"game_bans"`
	VacBans          int64        `json:"vac_bans"`
	LastVacBanOn     sql.NullTime `json:"last_vac_ban_on"`
	KillsOn          int64        `json:"kills_on"`
	DeathsBy         int64        `json:"deaths_by"`
	RageQuits        int64        `json:"rage_quits"`
	Notes            string       `json:"notes"`
	Whitelist        bool         `json:"whitelist"`
	UpdatedOn        time.Time    `json:"updated_on"`
	ProfileUpdatedOn time.Time    `json:"profile_updated_on"`
	Personaname      string       `json:"personaname"`
	SteamID          int64        `json:"steam_id"`
}

func (q *Queries) PlayerUpdate(ctx context.Context, arg PlayerUpdateParams) error {
	_, err := q.exec(ctx, q.playerUpdateStmt, playerUpdate,
		arg.Visibility,
		arg.RealName,
		arg.AccountCreatedOn,
		arg.AvatarHash,
		arg.CommunityBanned,
		arg.GameBans,
		arg.VacBans,
		arg.LastVacBanOn,
		arg.KillsOn,
		arg.DeathsBy,
		arg.RageQuits,
		arg.Notes,
		arg.Whitelist,
		arg.UpdatedOn,
		arg.ProfileUpdatedOn,
		arg.Personaname,
		arg.SteamID,
	)
	return err
}

const sourcebans = `-- name: Sourcebans :many
SELECT sourcebans_id, steam_id, site,  player_name, reason, duration, permanent, created_on
FROM player_sourcebans
WHERE steam_id = ?1
`

func (q *Queries) Sourcebans(ctx context.Context, steamID int64) ([]PlayerSourceban, error) {
	rows, err := q.query(ctx, q.sourcebansStmt, sourcebans, steamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerSourceban
	for rows.Next() {
		var i PlayerSourceban
		if err := rows.Scan(
			&i.SourcebansID,
			&i.SteamID,
			&i.Site,
			&i.PlayerName,
			&i.Reason,
			&i.Duration,
			&i.Permanent,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sourcebansDelete = `-- name: SourcebansDelete :exec
DELETE FROM player_sourcebans WHERE steam_id = ?1
`

func (q *Queries) SourcebansDelete(ctx context.Context, steamID int64) error {
	_, err := q.exec(ctx, q.sourcebansDeleteStmt, sourcebansDelete, steamID)
	return err
}

const sourcebansInsert = `-- name: SourcebansInsert :one
INSERT INTO player_sourcebans (steam_id, site, player_name, reason, duration, permanent, created_on)
VALUES (?,?,?,?, ?, ?, ?)
RETURNING sourcebans_id, steam_id, site, player_name, reason, duration, permanent, created_on
`

type SourcebansInsertParams struct {
	SteamID    int64     `json:"steam_id"`
	Site       string    `json:"site"`
	PlayerName string    `json:"player_name"`
	Reason     string    `json:"reason"`
	Duration   int64     `json:"duration"`
	Permanent  bool      `json:"permanent"`
	CreatedOn  time.Time `json:"created_on"`
}

func (q *Queries) SourcebansInsert(ctx context.Context, arg SourcebansInsertParams) (PlayerSourceban, error) {
	row := q.queryRow(ctx, q.sourcebansInsertStmt, sourcebansInsert,
		arg.SteamID,
		arg.Site,
		arg.PlayerName,
		arg.Reason,
		arg.Duration,
		arg.Permanent,
		arg.CreatedOn,
	)
	var i PlayerSourceban
	err := row.Scan(
		&i.SourcebansID,
		&i.SteamID,
		&i.Site,
		&i.PlayerName,
		&i.Reason,
		&i.Duration,
		&i.Permanent,
		&i.CreatedOn,
	)
	return i, err
}

const userNameSave = `-- name: UserNameSave :exec
INSERT INTO player_names (name_id, steam_id, name, created_on)
VALUES (?, ?, ?, ?)
`

type UserNameSaveParams struct {
	NameID    int64     `json:"name_id"`
	SteamID   int64     `json:"steam_id"`
	Name      string    `json:"name"`
	CreatedOn time.Time `json:"created_on"`
}

func (q *Queries) UserNameSave(ctx context.Context, arg UserNameSaveParams) error {
	_, err := q.exec(ctx, q.userNameSaveStmt, userNameSave,
		arg.NameID,
		arg.SteamID,
		arg.Name,
		arg.CreatedOn,
	)
	return err
}

const userNames = `-- name: UserNames :many
SELECT name_id, steam_id, name, created_on
FROM player_names
WHERE steam_id = ?1
`

func (q *Queries) UserNames(ctx context.Context, steamID int64) ([]PlayerName, error) {
	rows, err := q.query(ctx, q.userNamesStmt, userNames, steamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PlayerName
	for rows.Next() {
		var i PlayerName
		if err := rows.Scan(
			&i.NameID,
			&i.SteamID,
			&i.Name,
			&i.CreatedOn,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
